#!/bin/env python

##################################################################################################
#  Name:        rman_backup_report                                                               #
#  Author:      Randy Johnson                                                                    #
#  Description: Prints backup reports for RMAN database and FRA backups using the recovery       #
#               catalog.                                                                         #
#                                                                                                #
#  Input Parms: -h(elp)        Displays the Usage message.                                       #
#               -v(ersion)     Displays version information.                                     #
#                                                                                                #
#  Return Code: > 0 indicates failure.                                                           #
#                                                                                                #
##################################################################################################
# MODIFICATION HISTORY:                                                                          #
#                                                                                                #
# Date       Ver  Who              Change Description                                            #
# ---------- ---- ---------------- ------------------------------------------------------------  #
# 12/04/2012 1.00 Randy Johnson    Original report (backup_report2.sh by Mark Gulnac rewritten   #
#                                  in Python. Benefits: better run control, error checking,      #
#                                  better error handling, reduced three scripts down to 1 script.#
##################################################################################################


# --------------------------------------
# ---- Import Python Modules -----------
# --------------------------------------
from getpass                import getuser
from optparse               import OptionParser
from os                     import environ
from re                     import match
from re                     import search
from signal                 import SIGPIPE
from signal                 import SIG_DFL
from signal                 import signal
from socket                 import gethostname
from subprocess             import PIPE
from subprocess             import Popen
from subprocess             import STDOUT
from sys                    import exit


# --------------------------------------
# ---- Function Definitions ------------
# --------------------------------------

#---------------------------------------------------------------------------
# Def : RunSqlplus()
# Desc: Calls sqlplus and runs a sql script passed in in the Sql parameter.
#       Calls ErrorCheck() to scan for errors then calls PrintError if any
#       are found. The call stack looks like this...
#
#       CallingRoutine
#          ^    +-----> RunSqlplus()
#          |                +-----> ErrorCheck()
#          |                +-----> PrintError()
#          |                            +-----> LookupError()
#          |                                          |
#          |                +--> if error exit(rc)    |
#          +------------------------------------------+
#
#          1) Calling routing calls RunSqlplus
#                - 1 parameter. SQL to run (string)
#                - Returns Result Set (1 string)
#          2) RunSqlplus calls ErrorCheck
#                - 2 parameters. Sqlout (string), and ComponentList (List of components for looking up potential errors)
#                - Returns 2 values. Return code (int), and ErrorStack which is a list of lists ([ErrorString, line]
#          3) RunSqlplus calls PrintError
#                - Only if return code from ErrorCheck != 0 (an error was found)
#                - Calls PrintError with three parameters:
#                    Sql       = the original SQL statement run.
#                    Sqlout    = the output generated by the sqlplus session.
#                    ErrorList = the list of error codes and lines containing the errors (see #2 above).
#                - Returns Sqlout to calling routine.
#
# Args: String containing the SQL to execute.
# Retn: Return code and a dictionary of parameter values
#---------------------------------------------------------------------------
def RunSqlplus(SQL, ConnectString='/ as sysdba'):

  # Start Sqlplus and login
  Sqlproc = Popen([Sqlplus, '-s', ConnectString], stdin=PIPE, stdout=PIPE, stderr=STDOUT, \
   shell=False, universal_newlines=True, close_fds=True)

  # Execute the SQL
  Sqlproc.stdin.write(SQL)

  # Fetch the output
  Sqlout, SqlErr = Sqlproc.communicate()
  Sqlout = Sqlout.strip()      # remove leading/trailing whitespace

  # Check for sqlplus errors
  # Components are installed applications/components such as sqlplus, import, export, rdbms, network, ...
  # ComponentList contains a list of all components for which the error code will be searched.
  # For example a component of rdbms will result in ORA-nnnnn errors being included in the search.
  # ALL_COMPONENTS is an override in the ErrorCheck function that results in *all* installed components
  # being selected. Searching all component errors is pretty fast so for now we'll just search them all.
  # -------------------------------------------------------------------------------------------------------
  #ComponentList = ['sqlplus','rdbms','network','crs','css','evm','has','oracore','plsql','precomp','racg','srvm','svrmgr']
  ComponentList = ['sqlplus','rdbms', 'oracore']

  # Brief explanation of what is returned by ErrorCheck()
  # ------------------------------------------------------
  # rc is the return code (0 is good, anything else is bad). ErrorList is a list of list structures
  # (a 2 dimensional arrray in other languages). Each outer element of the array represents 1 error found
  # Sql output. Each inner element has two parts (2 fields), element[0] is the Oracle error code and
  # element[1] is the full line of text in which the error was found.
  # For example an ErrorList might look like this:
  # [['ORA-00001', 'ORA-00001: unique constraint...'],['ORA-00018', 'ORA-00018, 00000, "maximum number of..."']]
  (rc, ErrorList) = ErrorCheck(Sqlout, ComponentList)

  if (rc != 0):
    PrintError(Sql, Sqlout, ErrorList)
    exit(rc)

  return(Sqlout)
# End RunSqlplus()


# Def : ErrorCheck()
# Desc: Check tnsping, sqlplus, crsctl, srvctl output for errors.
# Args: Output(output you want to scan for errors)
# Retn: Returns 0=no errors or 1=error found, and error stack (in list form)
#-------------------------------------------------------------------------
def ErrorCheck(Sqlout, ComponentList=['ALL_COMPONENTS']):
  FacilityList = []
  ErrorStack   = []
  rc           = 0

  # Determine what errors to check for....
  for key in sorted(FacilitiesDD.keys()):
    if (ComponentList[0].upper() == 'ALL_COMPONENTS'):
      for Component in ComponentList:
        FacilityList.append(key.upper())
    else:
      for Component in ComponentList:
        if (Component == FacilitiesDD[key]['Component']):
          FacilityList.append(key.upper())

  # Component:
  #  Facility class is major error type such as SP1, SP2, IMP, TNS, ...
  #  Component class is the application such as sqlplus, rdbms, imp, network.
  #  A component can have several error facilities. For example the sqlplus
  #  has 5:
  #    grep sqlplus  /u01/app/oracle/product/11.2.0.3/dbhome_1/lib/facility.lis
  #    cpy:sqlplus:*:
  #    sp1:sqlplus:*:
  #    sp2:sqlplus:*:
  #    sp3:sqlplus:*:
  #    spw:sqlplus:*:
  #
  #  The error SP2-06063 breaks down as Component=sqlplus, Facility=sp2, Error=06063. See below:
  #    SP2-06063 : 06063,0, "When SQL*Plus starts, and after CONNECT commands, the site profile\n"
  #    SP2-06063 : // *Document: NO
  #    SP2-06063 : // *Cause:  Usage message.
  #    SP2-06063 : // *Action:

  for line in Sqlout.split('\n'):
    for Facility in FacilityList:
      # Check for warning and error messages
      matchObj = search(Facility + '-[0-9]+', line)
      if (matchObj):
        ErrorString = matchObj.group()
        rc = 1
        ErrorStack.append([ErrorString, line])

  return(rc, ErrorStack)
# End ErrorCheck()

# Def : LookupMessage()
# Desc: Parses the ficiliy file and returns a list of lists (2 dim array)
#       containing:
#         facility:component:rename:description
# Args: Facility file name.
# Retn: FacilitiesDD
#---------------------------------------------------------------------------
def LookupMessage(Error):
  MsgList     = []
  HeaderFound = False

  try:
    (Facility,ErrCode) = Error.lower().split('-')
  except:
    print('\nInvalid error code.')
    exit(1)

  if (not Facility in list(FacilitiesDD.keys())):
    print('\nInvalid facility:', Facility)
    exit(1)
  else:
    MessagesFile = OracleHome + '/' + FacilitiesDD[Facility]['Component'] + '/' + 'mesg' + '/' + Facility + 'us.msg'

  try:
    msgfil = open(MessagesFile, 'r')
  except:
    print('\nCannot open Messages file: ' + MessagesFile + ' for read.')
    exit(1)

  MsgFileContents = msgfil.readlines()

  for line in MsgFileContents:
    # lines I'm looking for look like this "00003, 00000, "INTCTL: error while se..."
    # So just looking for something that starts with a string of digits and contains
    # the error code I'm looking for.
    if (HeaderFound):
        matchObj = match(r'//,*', line)
        if (matchObj):
          MsgList.append(line.strip())
        else:
          return(MsgList)
    else:
      matchObj = match('[0]*' + ErrCode + ',', line)
      if (matchObj):
          ErrCode = matchObj.group()
          ErrCode = ErrCode[0:ErrCode.find(',')]
          MsgList.append(line.strip())
          HeaderFound = True

  if (len(MsgList) == 0):
    # If error code could not be found let's trim off leading 0's and try again...
    ErrCode = str(int(ErrCode))
    for line in MsgFileContents:
      # lines I'm looking for look like this "00003, 00000, "INTCTL: error while se..."
      # So just looking for something that starts with a string of digits and contains
      # the error code I'm looking for.
      if (HeaderFound):
          matchObj = match(r'//,*', line)
          if (matchObj):
            MsgList.append(line.strip())
          else:
            return(MsgList)
      else:
        matchObj = match('[0]*' + ErrCode + ',', line)
        if (matchObj):
            ErrCode = matchObj.group()
            ErrCode = ErrCode[0:ErrCode.find(',')]
            MsgList.append(line.strip())
            HeaderFound = True

  if (len(MsgList) == 0):
    print('Error not found  : ' + ErrCode)
    print('Msg file         : ' + MessagesFile)

  return(MsgList)
# End LookupMessage()


# Def : PrintError()
# Desc: Print a formatted error message.
# Args: ErrorMsg (the error message to be printed)
# Retn:
#---------------------------------------------------------------------------
def PrintError(Sql, Sqlout, ErrorList):
  print('\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')
  print(Sql)
  print('\n----\n')
  print(Sqlout)
  print('\n----')
  print()
  for Error in ErrorList:
    OracleError = Error[0]
    ErrorString = Error[1]
    Explanation = LookupMessage(OracleError)
    if (len(Explanation) > 0):
      print('\nExplanation:')
      print('---------------')
      for line in Explanation:
        print(line)
  print('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n')
  return
# End PrintError()


# Def : LoadFacilities()
# Desc: Parses the ficiliy file and returns a list of lists (2 dim array)
#       containing:
#         facility:component:rename:description
# Args: Facility file name.
# Retn: FacilitiesDD
#---------------------------------------------------------------------------
def LoadFacilities(FacilitiesFile):
  FacDict = {}
  FacDD   = {}

  try:
    facfil = open(FacilitiesFile, 'r')
  except:
    #formatExceptionInfo()
    print('\nCannot open facilities file: ' + FacilitiesFile + ' for read.')
    exit(1)

  FacFileContents = facfil.read().split('\n')
  for line in FacFileContents:
    if (not (search(r'^\s*$', line))):   # skip blank lines
      if (line.find('#') >= 0):
        line=line[0:line.find('#')]
      if (line.count(':') == 3):   # ignore lines that do not contain 3 :'s
        (Facility, Component, OldName, Description) = line.split(':')
        FacList = [strip(Facility), strip(Component), strip(OldName), strip(Description)]
        if (Facility != ''):
          FacDict = {
           'Component'   : strip(Component),
           'OldName'      : strip(OldName),
           'Description' : strip(Description)
          }
          FacDD[strip(Facility)] = FacDict
  return(FacDD)
# End LoadFacilities()


# Def : SetOracleEnv()
# Desc: Setup your environemnt (ORACLE_HOME, ORACLE_SID)
# Args: Sid = The ORACLE_SID of the home you want to configure for
#       (parses oratab file).
# Retn: OracleHome = $ORACLE_HOME
#---------------------------------------------------------------------------
def SetOracleEnv(Sid):
  OracleSid = ''
  OracleHome = ''

  try:
    Oratab = open(OratabFile)
  except:
    #formatExceptionInfo()
    print('\nCannot open oratab file: ' + OratabFile + ' for read.')
    exit(1)

  OratabContents = Oratab.read().split('\n')

  for line in OratabContents:
    if (line.count(':') >= 1):
      OracleSid  = line.split(':')[0]
      OracleHome = line.split(':')[1]
      if (Sid == OracleSid):
        environ['ORACLE_SID']   = OracleSid
        environ['ORACLE_HOME']  = OracleHome
        return(OracleHome)
  return('') # If got to this point then the Sid lookup failed.
# End SetOracleEnv()


# Def : LoadOratab()
# Desc: Parses the oratab file and returns a List of lists containing:
#       SID, ORACLE_HOME, Stop/Start Flag
# Args: none.
# Retn: OratabLL
#---------------------------------------------------------------------------
def LoadOratab(OratabFile):
  OracleSid =  ''
  OracleHome = ''
  Bootflag   = ''
  Oratab     = {}

  try:
    otab = open(OratabFile)
  except:
    #formatExceptionInfo()
    print('\nCannot open oratab file: ' + OratabFile + ' for read.')
    exit(1)

  OratabContents = otab.read().split('\n')
  for line in OratabContents:
    pos = line.find('#')
    if (pos >= 0):                     # Comment character found.
      if (pos > 0):                    # Comment isn't at the beginning of the line. (there is something to preserve)
        line = line[0:pos]
    line = line.strip()
    if (line != ''):
      Count = line.count(':')
      if (Count == 2):
        try:
          (OraSid, OraHome, Bootflag) = line.split(':')
          Oratab[OraSid] = OraHome
        except:
          pass
      elif (Count == 1):
        try:
          (OraSid, OraHome) = line.split(':')
          Oratab[OraSid] = OraHome
        except:
          pass
  return(Oratab)
# End LoadOratab()

# Def  : SendReport()
# Desc : Creates a multi-part MIME message.
# Args : AddressList, Report, Subject
# Retn : msg = Message object containing the multi-part MIME email message.
#---------------------------------------------------------------------------
def SendReport(AddressList, Report, Subject):
  hostname       = gethostname()
  username       = getuser()

  msg = MIMEMultipart('alternative')
  msg['From']    = username + '@' + hostname
  msg['To']      = COMMASPACE.join(AddressList)
  msg['Date']    = formatdate(localtime=True)
  msg['Subject'] = Subject

  msg.attach(MIMEText(Report, 'html'))
  msgText = msg.as_string()

  proc= Popen(['/usr/sbin/sendmail', '-t'], stdin=PIPE, stdout=PIPE, stderr=STDOUT, shell=False, universal_newlines=True, close_fds=True)

  # Write the contents of the mail message to sendmail's stdin and close.
  proc.stdin.write(msg.as_string())
  proc.stdin.close()

  # Catch stdout/stderr output.
  Stdout = proc.stdout.read()

  # Get the return code from sendmail
  rc = proc.poll()
  if (rc > 0):
    print("Error emailing report: " + Subject)
    print('---------')
    print(Stdout)
    print('---------')
    exit(rc) 

  return()
# End SendReport()

# --------------------------------------
# ---- End Function Definitions --------
# --------------------------------------




# --------------------------------------
# ---- Main Program --------------------
# --------------------------------------
if (__name__ == '__main__'):
  Version           = '1.0'
  Banner            = 'RMAN Backup Report, Release ' + Version + ' Production on Tue Dec 04 13:00:00 2012'
  OratabFile        = '/etc/oratab'
  OracleSid         = 'rmltr01'   # Used for setting the Oracle environment for executing the SQL queries in this report.
  DbUser            = 'rman'
  DbPwd             = 'r0cketMan'
  DbHost            = 'uscdcflo01.us.cbre.net'
  DbPort            = '1521'
  DbService         = 'rmltr01'
  MsgSizeLimit      = 26214400
  AddressList       = ['CBRE-OracleSupport@cbre.com']
  ###~ AddressList       = ['randy.johnson9@cbre.com']
  EZConnect         = DbUser + '/' + DbPwd + '@' + DbHost + ':' + DbPort + '/' + DbService

  parser = OptionParser()
  parser.add_option('-v', action="store_true", dest="Version", default=False, help="Print version information")
  Option, Args = parser.parse_args()

  # For handling termination in stdout pipe.
  #  ex. when you run: oerrdump | head
  #--------------------------------------------
  signal(SIGPIPE, SIG_DFL)

  if (Option.Version):
    print('\n', Banner, '\n')
    exit(0)
  else:
    print('\n', Banner, '\n')

  LoadOratab(OratabFile)
  OracleHome = SetOracleEnv(OracleSid)
  if (not OracleHome):
    print('\nError setting ORACLE_HOME using ORACLE_SID=' + OracleSid + '. This')
    print('is likely due to a lookup failure in the oratab file.')
    exit(1)
  else:
    Sqlplus  = OracleHome + '/bin/sqlplus'

    # Load error information used for error message lookup if a
    # Sqlplus, lsnrctl, etc. error occurs.
    # -------------------------------------------------------------
    FacilitiesFile = OracleHome + '/lib/facility.lis'
    FacilitiesDD = LoadFacilities(FacilitiesFile)

  #-- FRA (SBT_TAPE) Backup Report
  #---------------------------------
  SQL  = "SET ECHO OFF"                                                                                    + "\n"
  SQL += "SET FEEDBACK OFF"                                                                                + "\n"
  SQL += "COL COMPLETION_TIME HEADING 'COMPLETION|TIME' FORMAT A19"                                        + "\n"
  SQL += "COL DB_NAME HEADING 'DATABASE|NAME' FORMAT A20"                                                  + "\n"
  SQL += "COL DB_KEY HEADING 'DATABASE|KEY' FORMAT 9999999999"                                             + "\n"
  SQL += "COL BACKUP_TYPE HEADING 'BACKUP|TYPE' FORMAT A6"                                                 + "\n"
  SQL += "COL TIME_TAKEN HEADING 'TIME|TAKEN' FORMAT A19"                                                  + "\n"
  SQL += "COL DEVICE_TYPE HEADING 'DEVICE|TYPE' FORMAT A8"                                                 + "\n"
  SQL += "COL SESSION_KEY HEADING 'SESSION|KEY' FORMAT 9999999999"                                         + "\n"
  SQL += "ALTER SESSION SET NLS_DATE_FORMAT = 'mm-dd-yyyy HH24:mi:ss';"                                    + "\n"
  SQL += "SET MARKUP HTML ON SPOOL ON PREFORMAT OFF ENTMAP ON -"                                           + "\n"
  SQL += "HEAD \"<TITLE>RMAN Produdution to tape Backup Report from RMAN Repository</TITLE> -"             + "\n"
  SQL += "<STYLE type='text/css'> -"                                                                       + "\n"
  SQL += "<!-- BODY {background: #FFFFC6} --> -"                                                           + "\n"
  SQL += "</STYLE>\" -"                                                                                    + "\n"
  SQL += "BODY \"TEXT='#FF00Ff'\" -"                                                                       + "\n"
  SQL += "TABLE \"WIDTH='90%' BORDER='5'\""                                                                + "\n"
  SQL += "SELECT max(a.DB_NAME) DB_NAME,"                                                                  + "\n"
  SQL += "       a.DB_KEY,"                                                                                + "\n"
  SQL += "       a.DEVICE_TYPE,"                                                                           + "\n"
  SQL += "       max(a.COMPLETION_TIME) COMPLETION_TIME,"                                                  + "\n"
  SQL += "       A.TIME_TAKEN_DISPLAY TIME_TAKEN,"                                                         + "\n"
  SQL += "       A.SESSION_KEY,"                                                                           + "\n"
  SQL += "       A.BACKUP_TYPE,"                                                                           + "\n"
  SQL += "       C.STATUS"                                                                                 + "\n"
  SQL += "  FROM rman.RC_BACKUP_SET_DETAILS a, rman.RC_RMAN_STATUS c"                                      + "\n"
  SQL += " WHERE a.COMPLETION_TIME = ("                                                                    + "\n"
  SQL += "          SELECT MAX (COMPLETION_TIME)"                                                          + "\n"
  SQL += "            FROM rman.RC_BACKUP_SET_DETAILS b"                                                   + "\n"
  SQL += "           WHERE b.DB_NAME = a.DB_NAME"                                                          + "\n"
  SQL += "                 AND b.DB_KEY = a.DB_KEY"                                                        + "\n"
  SQL += "                 AND B.BACKUP_TYPE = A.BACKUP_TYPE"                                              + "\n"
  SQL += "                 AND b.DEVICE_TYPE = a.DEVICE_TYPE"                                              + "\n"
  SQL += "       )"                                                                                        + "\n"
  SQL += "   AND a.DB_NAME = C.DB_NAME"                                                                    + "\n"
  SQL += "   AND A.DB_KEY = C.DB_KEY"                                                                      + "\n"
  SQL += "   AND A.SESSION_KEY = c.SESSION_KEY"                                                            + "\n"
  SQL += "   AND A.DEVICE_TYPE IN ('SBT_TAPE')"                                                            + "\n"
  SQL += "   AND C.ROW_LEVEL = ("                                                                          + "\n"
  SQL += "          SELECT MAX (d.ROW_LEVEL)"                                                              + "\n"
  SQL += "            FROM rman.RC_RMAN_STATUS d"                                                          + "\n"
  SQL += "           WHERE d.DB_NAME     = a.DB_NAME"                                                      + "\n"
  SQL += "             AND d.DB_KEY      = a.DB_KEY"                                                       + "\n"
  SQL += "             AND d.SESSION_KEY = a.SESSION_KEY"                                                  + "\n"
  SQL += "       )"                                                                                        + "\n"
  SQL += "   AND A.BACKUP_TYPE = 'D'"                                                                      + "\n"
  SQL += "   AND a.DB_NAME LIKE '%PRD%'"                                                                   + "\n"
  SQL += "   AND a.db_key NOT IN (SELECT db_key FROM cbre_stale_backup_excp)"                              + "\n"
  SQL += " GROUP BY a.DB_KEY, a.DEVICE_TYPE, A.TIME_TAKEN_DISPLAY, A.SESSION_KEY, A.BACKUP_TYPE, C.STATUS" + "\n"
  SQL += " ORDER BY max(a.DB_NAME), max(a.COMPLETION_TIME);"                                               + "\n"
  ###~ print SQL

  # Run the report
  print('Executing Tape Backup Report.')
  Sqlout = RunSqlplus(SQL, EZConnect)
  
  # Email the report
  TapeBackupReport  = "<html><head><title>HTML E-mail</title></head><body>"     
  TapeBackupReport += Sqlout
  TapeBackupReport += "</body></html>"      
  print('Emailing Tape Backup Report.\n')
  SendReport(AddressList, TapeBackupReport, 'RMAN Backups: Tape Backup Report')
  
  #-- Database/Archivelog Backup Report
  #--------------------------------------
  SQL  = "COL NAME   HEADING 'DATABASE|NAME'          FORMAT A10"                                                   + "\n"
  SQL += "COL DBBKP  HEADING 'LAST|DATABASE|BACKUP'   FORMAT A19"                                                   + "\n"
  SQL += "COL ARCBKP HEADING 'LAST|ARCHIVELOG|BACKUP' FORMAT A19"                                                   + "\n"
  SQL += "SET PAGES 200"                                                                                            + "\n"
  SQL += "SET FEEDBACK OFF"                                                                                         + "\n"
  SQL += "SET MARKUP HTML ON SPOOL ON PREFORMAT OFF ENTMAP ON -"                                                    + "\n"
  SQL += "HEAD \"<TITLE>RMAN Backup Report from RMAN Repository 10g</TITLE> -"                                      + "\n"
  SQL += "<STYLE type='text/css'> -"                                                                                + "\n"
  SQL += "<!-- BODY {background: #FFFFC6} --> -"                                                                    + "\n"
  SQL += "</STYLE>\" -"                                                                                             + "\n"
  SQL += "BODY \"TEXT='#FF00Ff'\" -"                                                                                + "\n"
  SQL += "TABLE \"WIDTH='90%' BORDER='5'\""                                                                         + "\n"
  SQL += "SELECT DB NAME,dbid,"                                                                                     + "\n"
  SQL += "       NVL(TO_CHAR(max(backuptype_db),'MM/DD/YYYY HH24:MI'),'01/01/1000 00:00') DBBKP,"                   + "\n"
  SQL += "       NVL(TO_CHAR(max(backuptype_arch),'MM/DD/YYYY HH24:MI'),'01/01/1000 00:00') ARCBKP"                 + "\n"
  SQL += "  FROM ( SELECT a.name DB,dbid,"                                                                          + "\n"
  SQL += "                decode(b.bck_type,'D',max(b.completion_time),'I', max(b.completion_time)) BACKUPTYPE_db," + "\n"
  SQL += "                decode(b.bck_type,'L',max(b.completion_time)) BACKUPTYPE_arch"                            + "\n"
  SQL += "           FROM rc_database a, bs b"                                                                      + "\n"
  SQL += "          WHERE a.db_key=b.db_key"                                                                        + "\n"
  SQL += "            AND b.bck_type is not null"                                                                   + "\n"
  SQL += "            AND b.bs_key not in ("                                                                        + "\n"
  SQL += "                   SELECT bs_key"                                                                         + "\n"
  SQL += "                     FROM rc_backup_controlfile"                                                          + "\n"
  SQL += "                    WHERE AUTOBACKUP_DATE is not null"                                                    + "\n"
  SQL += "                       OR AUTOBACKUP_SEQUENCE is not null"                                                + "\n"
  SQL += "                )"                                                                                        + "\n"
  SQL += "            AND b.bs_key not in ( select bs_key from rc_backup_spfile)"                                   + "\n"
  SQL += "          GROUP by a.name,dbid,b.bck_type"                                                                + "\n"
  SQL += "        )"                                                                                                + "\n"
  SQL += " WHERE dbid NOT IN (SELECT dbid FROM cbre_stale_backup_excp)"                                             + "\n"
  SQL += " GROUP BY db,dbid"                                                                                        + "\n"
  SQL += " ORDER BY to_date(DBBKP,'MM/DD/YYYY HH24:MI') desc;"                                                      + "\n"
  ###~ print SQL
  
  # Run the report
  print('Executing Database Backup Report.')
  Sqlout = RunSqlplus(SQL, EZConnect)

  # Email the report
  DbBackupReport  = "<html><head><title>HTML E-mail</title></head><body>"     
  DbBackupReport += Sqlout
  DbBackupReport += "</body></html>"      
  print('Emailing Database Backup Report.\n')
  SendReport(AddressList, DbBackupReport, 'RMAN Backups: Database Backup Report')
  
  print('RMAN Backup Report Complete.')
  exit()
# --------------------------------------
# ---- End Main Program ----------------
# --------------------------------------

