#!/bin/env python

##################################################################################################
#  Name:        copymon                                                                          #
#  Author:      Randy Johnson                                                                    #
#  Description: Monitors a file copy progress and estimates the completion time.                 #
#                                                                                                #
#  Usage: usage: transest [options]                                                              #
#  options:                                                                                      #
#    -h, --help   show this help message and exit.                                               #
#    -d LZSUBDIR  Landing zone sub directory.                                                    #
#    -f FILTER    Where filename like *Filter*.                                                  #
#    -m MANIFEST  Manifest.                                                                      #
#    -t           Print minimal output.                                                          #
#    -v           print version info.                                                            #
#                                                                                                #
# History:                                                                                       #
#                                                                                                #
# Date       Ver. Who              Change Description                                            #
# ---------- ---- ---------------- ------------------------------------------------------------- #
# 12/10/2014 1.00 Randy Johnson    Initial release.                                              #
# 05/31/2015 1.01 Randy Johnson    Updated for Python 3.                                         #
#                                                                                                #
# Todo's                                                                                         #
#  - None at this time.                                                                          #
#                                                                                                #
# Wish List:                                                                                     #
#  - None at this time.                                                                          #
##################################################################################################


# --------------------------------------
# ---- Import Python Modules -----------
# --------------------------------------
from datetime  import datetime
from datetime  import timedelta
from math      import floor
from math      import log
from math      import pow
from os.path   import join as pathjoin
from os.path   import basename
from sys       import exit
from sys       import argv
from sys       import stdout
from sys       import path
from optparse  import OptionParser
from re        import compile
from re        import match
from re        import search
from re        import IGNORECASE
from os        import walk
from os        import stat


# --------------------------------------
# -- Function/Class Definitions --------
# --------------------------------------

# Def : ConvertSize()
# Desc: Reduces the size of a number from Bytes .. Yeta Bytes
# Args: s    = numeric_string
#       tSep = thousands_separation_character (default is ',')
#       dSep = decimal_separation_character (default is '.')
# Retn: formatted string
#---------------------------------------------------------------------------
def ConvertSize(bytes):
   size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
   i = int(floor(log(bytes,1024)))
   p = pow(1024,i)
   s = round(bytes/p,2)

   if (s > 0):
       return '%s %s' % (s,size_name[i])
   else:
       return '0B'
# End ConvertSize


# Def : splitThousands()
# Desc: Simple function to format numbers with commas to separate thousands.
# Args: s    = numeric_string
#       tSep = thousands_separation_character (default is ',')
#       dSep = decimal_separation_character (default is '.')
# Retn: formatted string
#---------------------------------------------------------------------------
def splitThousands( s, tSep=',', dSep='.'):
  '''Splits a general float on thousands. GIGO on general input'''
  if s == None:
    return(0)
  if not isinstance( s, str ):
    s = str( s )

  cnt=0
  numChars=dSep+'0123456789'
  ls=len(s)
  while cnt < ls and s[cnt] not in numChars: cnt += 1

  lhs = s[ 0:cnt ]
  s = s[ cnt: ]
  if dSep == '':
    cnt = -1
  else:
    cnt = s.rfind( dSep )
  if cnt > 0:
    rhs = dSep + s[ cnt+1: ]
    s = s[ :cnt ]
  else:
    rhs = ''

  splt=''
  while s != '':
    splt= s[ -3: ] + tSep + splt
    s = s[ :-3 ]

  return(lhs + splt[ :-1 ] + rhs)
# End splitThousands

# --------------------------------------
# -- End Function/Class Definitions ----
# --------------------------------------


# --------------------------------------
# ---- Main Program --------------------
# --------------------------------------
if (__name__ == '__main__'):
  Cmd            = basename(argv[0])
  CmdPrefix      = Cmd.split('.')[0]
  CmdDesc        = 'File Copy Monitor (' + Cmd + ')'
  VersionDate    = 'Sun May 31 20:42:56 EDT 2015'
  Version        = '1.01'
  Banner         = CmdDesc + ', Release ' + Version + ' Production, ' + VersionDate
  ArgParser      = OptionParser()
  Interactive    = stdout.isatty()
  LzPathList     = []
  PathList       = []
  Now            = datetime.now()
  Found          = True
  ExpectedBytes  = 0
  ExpectedCount  = 0
  ActualBytes    = 0
  ActualCount    = 0
  ManifestDict   = {}

  # Process command line options
  # ----------------------------------
  ArgParser.add_option("-d",  dest="LandingZone", default='./',                       type=str, help="Landing zone directory(s).")
  ArgParser.add_option("-f",  dest="Filter",      default='',                         type=str, help="Where filename like *Filter*.")
  ArgParser.add_option("-m",  dest="Manifest",    default='',                         type=str, help="Manifest.")
  ArgParser.add_option("-t",  dest="Terse",       default=False, action="store_true",           help="Print minimal output.")
  ArgParser.add_option("--v", dest="ShowVer",     default=False, action="store_true",           help="Print version info.")

  Options, args = ArgParser.parse_args()
  argc = len(args)

  if (Options.ShowVer):
    print("\n%s" % Banner)
    exit()

  LandingZone   = Options.LandingZone
  Filter        = Options.Filter
  Manifest      = Options.Manifest
  Terse         = Options.Terse

  if (Manifest == ''):
    print('Manifest file name (-m filename) is reqired.')
    exit(1)

  # Set the list of directories to search for copied files.
  # ---------------------------------------------------------
  LzPathList = LandingZone.split(',')

  # Open the manifest and load up the list of files.
  # -------------------------------------------------
  try:
    h = open(Manifest, 'r')
  except:
    print('Cannot open file transfer manifest for read: %s' % Manifest)
    exit(1)

  if (Filter != ''):
    Filemask = compile(r'^.*' + Filter + '.*')
  else:
    Filemask = compile(r'^.*')

  RecNo = 0
  for line in h.read().split('\n'):
    RecNo += 1
    line = line.strip()
    if (line != ''):
      if (Filemask.search(line)):
        try:
          Bytes, Filename = line.split()
        except:
          print('Record parsing failed in manifest: %s' % Manifest)
          print('Record format must be: "Bytes Filename"')
          print('Error at line: %s >> %s' % (RecNo, line))
          exit(1)

        ExpectedBytes += int(Bytes)
        ExpectedCount += 1
        ManifestDict[Filename] = Bytes

  TargetDict    = {}
  ActualBytes   = 0
  ActualCount   = 0

  # Walk the directory and subs and load up the list with files found.
  # -------------------------------------------------------------------
  for StartingDir in LzPathList:
    StartingDir = pathjoin(StartingDir)
    for (path, dirs, files) in walk(StartingDir):
      for file in files:
        if (Filemask.search(file)):
          filepath = pathjoin(path,file)
          (mode,inode,dev,nlink,uid,gid,bytes,atime,mtime,ctime) = stat(filepath)
          PathList.append((ctime,filepath,bytes,atime,mtime))
          ActualBytes += bytes
          ActualCount += 1


  # The first file creation time will be the starting time for
  # for the file transfer. This is used to determine elapsed time.
  # ----------------------------------------------------------------
  if (len(PathList) > 0):
    SortedPathList = sorted(PathList)
    BeginTime      = SortedPathList[0][0]
    EndTime        = int(datetime.now().strftime('%s'))
  else:
    print('No files found.')
    exit()

  ElapseSeconds = EndTime - BeginTime
  TotalSize     = ConvertSize(ActualBytes)
  RemaingBytes  = ExpectedBytes - ActualBytes

  if (RemaingBytes <= 0):
    print('\nTransfer complete')
    exit()

  BytesPerSecond = ActualBytes / ElapseSeconds
  sec = timedelta(seconds = (RemaingBytes / BytesPerSecond))
  rt = datetime(1,1,1) + sec

  # Print the report. Two formats provided. 1) Complete 2) Terse
  # ----------------------------------------------------------------
  if (Terse == False):
    print('==============================================================================');
    print('File Copy Monitor                 %44s' % (Now.strftime("%Y-%m-%d %H:%M")));
    print('==============================================================================');
    print('Landing zone      :', LzPathList[0])
    if (len(LzPathList) > 1):
      print('                  :', LzPathList[1:len(LzPathList)].join('\n                  : '))

  if (Filter != ''):
    print('Filename Filter   : *%s*'    % (Filter))
  else:
    print('Filename Filter   : <none>')

  print('Files Transferred : %s of %s'    % (splitThousands(ActualCount), splitThousands(ExpectedCount)))
  print('Bytes Transferred : %s of %s'    % (ConvertSize(ActualBytes), ConvertSize(ExpectedBytes)))
  print('Bytes per Sec     : %-20s'       % (splitThousands(BytesPerSecond)))
  print('Time Remaining    : %d:%d:%d:%d' % (rt.day-1, rt.hour, rt.minute, rt.second))

  exit(0)
# --------------------------------------
# ---- End Main Program ----------------
# --------------------------------------
